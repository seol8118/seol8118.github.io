---
title: "DSSD"
date: 2020-06-29
category:
  - object detection
tag :
  - object detection
sidebar:
  nav: sidebar-odOnestage
mathjax: "true"
author_profile: false
toc: true
toc_label: "Contents"
toc_icon: "cog"
toc_sticky: true
header:
  overlay_image: /assets/images/dataScience.jpg
  overlay_filter: 0.5
comments: true
---

> ML study > Object Detection > One stage detection

<script type="text/javascript" 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

# DSSD
- SSD가 기존 YOLO 보다 높은 mAP와 속도를 얻었지만 여전히 작은 물체에 대해서는 성능이 좋지 못하다 판단하여 backbone network를 변경하고 deconvolutional detector를 적용함으로써 mAP를 개선시켰다.

## 1. DSSD 동작

- 우선 기존 SSD에서 사용되었던 VGG network를 조금 더 좋은 성능을 보이는 Residual-101 network로 교체하였다.

<center><img src="/assets/images/od/DSSD01.jpg" ></center>

[<center>Source</center>](https://arxiv.org/pdf/1701.06659.pdf)

- 위 그림은 SSD와 DSSD의 network 차이를 나타낸 그림이다. 첫 번째 SSD에서는 backbone layer를 지나 다양한 feature map에서 detection이 일어나는 방식이었다.

- 반면 DSSD는 deconvolutional network까지 추가하여 성능향상을 이루었다.

### 1.1 Prediction Module
<center><img src="/assets/images/od/DSSD02.jpg" ></center>

[<center>Source</center>](https://arxiv.org/pdf/1701.06659.pdf)

- Prediction module 로는 기존의 SSD module (a) 와 residual path를 추가해가며 module (b)-(d)를 만들어 성능을 비교했으며 (c)에서 가장 좋은 성능을 보였다.




### 1.2 Deconvolutional SSD

- Deconvolution module는 feature map을 deconvolution network로 upsampling하고 이전의 feature map과 합치는 방식으로 두 개의 feature map을 합칠 때 elementwise sum 과 product 방식을 나누어 실험하였고 product 방식의 결과가 더 좋게 나왔다.
 


### 1.3 Deconvolution Module
### 1.4 Training

<center><img src="/assets/images/od/SSDBlog.jpg" ></center>

[<center>Source</center>](https://arxiv.org/pdf/1512.02325.pdf)

- 구체적인 detection 과정은 위 그림과 같이  YOLO와 거의 동일하다. backbone을 통과한 feature map이  5x5x256인 경우를 살펴보자. 5x5는 YOLO에서의 grid size를 의미하며 grid 마다 3개의 anchor box를 만들어 낸다. 따라서 Default box generator에서 75개의 box가 만들어지는 것이다.

- 두 번째로 localization을 위해 conv net을 한번 통과시켜 5x5x12로 만드는데 이 때 anchor box (3개) 마다 box의 좌표(4개)를 나타내기 위해서 channel 수가 12 (3x4) 가 되는 것이다. 

- 마지막으로 confidence는 anchor box마다 class probability를 mapping 시켜주는 것으로 PASCAL VOC data 기준으로 배경을 포함하여 21개의 class가 존재하므로 channel 수는 63 (3x21) 이 된다. 이로 부터 bounding box와 class를 mapping 할 수 있게 되며 마지막으로 non maximum suppression 과정을 거쳐 최종 BB를 추론하게 된다.

### 1.2 Training

- Training 을 위해 각각의 ground truth에 IoU 0.5 이상인 default box를 matching 시켜 training 하였으며 Hard negative mining 기법을 사용하여 negative : positive 의 비율이 3:1이 되도록 training 하였다. 

<center><img src="/assets/images/od/SSDE01.jpg" ></center>

[<center>Source</center>](https://arxiv.org/pdf/1512.02325.pdf)

- Loss function은 Faster R-CNN과 동일하게 confidence loss (multiple class에 대한 softmax loss)와 localization loss (L1 loss between predicted box and ground truth box) 의 합으로 설정하였다.

<center><img src="/assets/images/od/SSDE04.jpg" ></center>

[<center>Source</center>](https://arxiv.org/pdf/1512.02325.pdf)

- Default box 는 위 수식과 같이 scale과 aspect ratio이 다르게하여 feature map마다 k개의 box가 나오도록 결정하였다. 이렇게 되면 아래 그림과 같이 각각의 feature map에서 동일한 box가 적용되었을 때 다양한 size의 object에 대해 detect할 수 있게 된다.

<center><img src="/assets/images/od/SSD01.jpg" ></center>

[<center>Source</center>](https://arxiv.org/pdf/1512.02325.pdf)



## 2. SSD 결과

PASCAL VOC 2007에 대해서 실험한 결과 input size와 batch size에 따라서 74~76 mAP 성능을 얻었으며 SSD 300에서는 Faster RCNN과 YOLO 보다 더 빠르고 높은 정확도를 보였다.

<!--며 fully convolutional network를 한번에 training 시키기 어려웠다.
-->
<center><img src="/assets/images/od/SSDT07.jpg" ></center>

[<center>Source</center>](https://arxiv.org/pdf/1512.02325.pdf)




## Reference
\[1]: [DSSD](https://arxiv.org/pdf/1701.06659.pdf)


<br><br>
